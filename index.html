<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Innovate Inc. Architecture Diagrams</title>

  <!-- Cytoscape core + Dagre layout -->
  <script src="https://unpkg.com/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
  <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="toolbar">
    <select id="diagramSelect" title="Select diagram JSON">
      <option value=".infra/innovate-high-level-architecture.json">Innovate High Level Architecture</option>
      <option value=".infra/innovate-cicd-dataflow.json">Innovate CICD Dataflow</option>
      <option value=".infra/innovate-eks-architecture.json">Innovate EKS Architecture</option>
      <option value=".infra/innovate-network-architecture.json">Innovate Network Architecture</option>
    </select>

    <input id="searchBox" type="text" placeholder="Search nodes..." />
    <label class="scale-label">
      <span>Scale</span>
      <input id="scalePercent" class="scale-input" type="number" min="10" max="200" value="95" title="Scale percent applied after fit">
      <span class="scale-unit">%</span>
    </label>
    <button id="btnFit">Fit</button>
    <button id="btnZoomIn">+</button>
    <button id="btnZoomOut">âˆ’</button>
  </div>

  <div id="cy"></div>
  <div class="legend">Tip: Click a node to focus. Drag to pan. Scroll to zoom.</div>

  <script>
    cytoscape.use(cytoscapeDagre);

    // Read colors from CSS variables so all color values live in style.css
    const __css = getComputedStyle(document.documentElement);
    const colors = {
      bg: __css.getPropertyValue('--bg').trim(),
      panel: __css.getPropertyValue('--panel').trim(),
      text: __css.getPropertyValue('--text').trim(),
      muted: __css.getPropertyValue('--muted').trim(),
      accent: __css.getPropertyValue('--accent').trim(),
      border: __css.getPropertyValue('--border').trim(),
      edge: (__css.getPropertyValue('--edge') || __css.getPropertyValue('--muted')).trim(),
      highlight: (__css.getPropertyValue('--highlight') || '#ffd166').trim()
    };

    const cy = cytoscape({
      container: document.getElementById('cy'),
      wheelSensitivity: 0.2,
      boxSelectionEnabled: true,
      style: [
        {
          selector: 'node',
          style: {
            'shape': 'round-rectangle',
            'background-color': colors.panel,
            'border-color': colors.border,
            'border-width': 1,
            'label': 'data(display)',
            'color': colors.text,
            'font-size': 16,
            'text-wrap': 'wrap',
            'text-max-width': 140,
            'padding': 12,
            'width': 140,
            'height': 140,
            'text-valign': 'bottom',
            'text-margin-y': 22,
            'text-halign': 'center',
            'overlay-opacity': 0,
          }
        },
        {
          selector: 'node[icon]',
          style: {
            'background-image': 'data(icon)',
            'background-fit': 'contain',
            'background-width': '48px',
            'background-height': '48px',
            'background-clip': 'none',
            'background-image-crossorigin': 'anonymous',
            'background-opacity': 1
          }
        },
        {
          selector: 'node#prometheus, node#grafana, node#fluentbit',
          style: {
            'background-width': '1px',
            'background-height': '1px',
            'background-fit': 'contain'
          }
        },
        {
          /* containers: VPC, AZs, Subnets, etc. */
          selector: 'node.container',
          style: {
            'shape': 'round-rectangle',
            'background-color': colors.panel,
            'border-color': colors.accent,
            'border-width': 2,
            'border-style': 'dotted',
            'border-dash-array': '8 8',
            'text-valign': 'top',
            'text-margin-y': -8,
            'font-size': 16,
            // containers should auto-size to their children: don't force fixed width/height
            'width': 'auto',
            'height': 'auto',
            // containers should not show the large icon background (keeps child icons readable)
            'background-image': 'none',
            'padding': 18
          }
        },
        {
          selector: 'edge',
          style: {
            'line-color': colors.edge,
            'width': 2,
            'target-arrow-shape': 'triangle',
            'target-arrow-color': colors.edge,
            'curve-style': 'bezier',
            'label': 'data(label)',
            'font-size': 10,
            'text-background-color': colors.bg,
            'text-background-opacity': 0.7,
            'text-background-padding': 2,
            'color': colors.muted
          }
        },
        { selector: '.highlight', style: { 'border-color': colors.highlight, 'border-width': 3, 'line-color': colors.highlight, 'target-arrow-color': colors.highlight } },
        { selector: '.rank-edge', style: { 'line-opacity': 0, 'target-arrow-shape': 'none', 'width': 0 } },
        { selector: ':selected', style: { 'border-color': colors.accent, 'border-width': 3, 'border-style': 'dashed', 'border-dash-array': '10 6' } }
      ]
    });

    // Dagre layout for L->R architecture flow
    const layoutOptions = { name: 'dagre', rankDir: 'LR', nodeSep: 220, edgeSep: 60, rankSep: 260 };

    const selectEl = document.getElementById('diagramSelect');
    const searchEl = document.getElementById('searchBox');
    const scaleEl = document.getElementById('scalePercent');

    // Initialize scale percent from localStorage or default to 95
    (function initScale() {
      try {
        const saved = localStorage.getItem('scalePercent');
        const val = saved ? Number(saved) : null;
        if (val && Number.isFinite(val)) scaleEl.value = val;
        else scaleEl.value = 95;
      } catch (e) { scaleEl.value = 95; }
    })();

    scaleEl.addEventListener('change', () => {
      const v = Number(scaleEl.value) || 95;
      const clamped = Math.max(10, Math.min(200, v));
      scaleEl.value = clamped;
      try { localStorage.setItem('scalePercent', String(clamped)); } catch (e) {}
    });

    function getScalePercent() { return Math.max(10, Math.min(200, Number(scaleEl.value) || 95)); }

    function applyScalePercent(percent, duration = 250) {
      try {
        const p = (typeof percent === 'number') ? percent : getScalePercent();
        const target = cy.zoom() * (p / 100);
        cy.animate({ zoom: target }, { duration });
      } catch (e) { /* ignore */ }
    }

    function normalizeIconPath(icon) {
      if (!icon) return null;
      // Your JSON uses /icons/aws/... -> host under /assets/icons/aws/...
      if (icon.startsWith('/icons/')) return icon.replace('/icons/', '/assets/icons/');
      return icon;
    }

    // Create elements from your schema (supports parentNode, type=container, position.relativeTo, edges)
    function toCytoscapeElements(json) {
      const elements = [];
      const containerIds = new Set();

      // Build nodes

      (json.nodes || []).forEach(n => {
        const display = n.subtitle ? `${n.label || n.id}\n${n.subtitle}` : (n.label || n.id);
        const data = {
          id: n.id,
          label: n.label || n.id,
          subtitle: n.subtitle || null,
          display,
          icon: normalizeIconPath(n.icon),
        };

        const node = { data };

        // Mark container nodes with a class
        if (n.type === 'container') {
          node.classes = 'container';
          containerIds.add(n.id);
        }

        // Compound parent relationship
        if (n.parentNode) data.parent = n.parentNode;

        elements.push(node);

        // Optional: nudging rank if positioned "above" a relative node (e.g., ALB above VPC)
        if (n.position && n.position.relativeTo && n.position.side === 'above') {
          // Dagre trick: add invisible edge from target to this node to raise rank
          elements.push({
            data: {
              id: `rank-${n.id}`,
              source: n.position.relativeTo,
              target: n.id,
              _rankEdge: true
            },
            classes: 'rank-edge'
          });
        }
      });

      // Build edges
      (json.edges || []).forEach(e => {
        const source = e.source || e.from;
        const target = e.target || e.to;
        if (!source || !target) return;
        elements.push({
          data: {
            id: `${source}-->${target}-${Math.random().toString(36).slice(2,7)}`,
            source,
            target,
            label: e.label || ''
          }
        });
      });

      return elements;
    }

    async function loadDiagram(path) {
      const res = await fetch(path);
      if (!res.ok) { alert(`Failed to load ${path}: ${res.status}`); return; }
      const json = await res.json();
      const elements = toCytoscapeElements(json);
      cy.elements().remove();
        cy.add(elements);

        // Two-stage layout:
        // 1) Run Dagre on top-level nodes (those without a parent) so global flow is left->right.
        const topLevelEles = cy.elements().filter(ele => {
          if (ele.isEdge()) {
            const src = cy.getElementById(ele.data('source'));
            const tgt = cy.getElementById(ele.data('target'));
            // keep edges that connect top-level nodes (no parent) or connect containers
            return (!src.data('parent') && !tgt.data('parent')) || (src.data('parent') !== tgt.data('parent'));
          }
          return ele.isNode() && !ele.data('parent');
        });

        await (async () => {
          const dagreLayout = cy.layout(Object.assign({}, layoutOptions, { animate: true, fit: false, boundingBox: undefined, name: 'dagre' }));
          try { dagreLayout.run(); } catch (e) { /* ignore layout errors */ }
          // give layout a moment
          await new Promise(r => setTimeout(r, 250));
        })();

        // 2) For each container, layout children inside a grid to make them tidy
        // Use per-diagram presets to tune rows/cols/width for specific containers
        const diagramKey = path.split('/').pop();
        const presets = {
          'innovate-cicd-dataflow.json': {
            'data-flow': { cols: 2, rows: 3, width: 420 },
            // smaller grouped containers
          },
          'innovate-eks-architecture.json': {
            'eks-cluster': { cols: 1, rows: 1, width: 620 },
            'ns-monitoring': { cols: 3, rows: 1, width: 520 },
            'ns-prod': { cols: 3, rows: 3, width: 640 },
            'ns-system': { cols: 1, rows: 3, width: 200 }
          },
          'innovate-high-level-architecture.json': {
            'vpc': { cols: 2, rows: 3, width: 420 }
          },
          'innovate-network-architecture.json': {
            'vpc-main': { cols: 2, rows: 4, width: 720 },
            'az-1a': { cols: 1, rows: 3, width: 200 },
            'az-1b': { cols: 1, rows: 3, width: 200 },
            'az-1c': { cols: 1, rows: 3, width: 200 }
          }
        };

        // Use an async for-loop so we can await between layout steps and avoid JS syntax errors
        const containers = cy.nodes('.container').toArray();
        for (const container of containers) {
          const children = cy.nodes().filter(n => n.data('parent') === container.id());
          if (children.length === 0) continue;

          // pick preset if available
          const cfg = (presets[diagramKey] && presets[diagramKey][container.id()]) || {};
          const cols = cfg.cols || Math.min(4, children.length) || 1;
          const rows = cfg.rows || Math.max(1, Math.ceil(children.length / cols));
          // wider cell sizes to avoid overlap between icons and labels
          const width = cfg.width || Math.max(400, Math.min(2200, children.length * 240));
          const height = Math.max(240, rows * 180);

          // Compute a bounding box centered inside the container position (initial placement)
          const cpos = container.position();
          const bbox = { x1: cpos.x - width/2 + 20, y1: cpos.y - height/2 + 18, x2: cpos.x + width/2 - 20, y2: cpos.y + height/2 - 18 };

          try {
            children.layout({ name: 'grid', boundingBox: bbox, avoidOverlap: true, avoidOverlapPadding: 60, spacingFactor: 2.2, rows, cols, animate: true, fit: false }).run();
            // after children are placed, compute their bounding box and center the container on them
            await new Promise(r => setTimeout(r, 120));
            const childBB = children.boundingBox({ includeNodes: true });
            if (childBB && Number.isFinite(childBB.x1)) {
              const cx = (childBB.x1 + childBB.x2) / 2;
              const cyPos = (childBB.y1 + childBB.y2) / 2;
              // move the container to center of children so its border fits nicely
              container.position({ x: cx, y: cyPos });
            }
          } catch (e) { /* ignore */ }
        }

        // Final fit (show everything and then apply user-chosen scale percent)
        cy.fit(120);
        applyScalePercent(getScalePercent(), 250);
    }

    // Controls
    // Fit now re-runs the tidy layout (dagre + per-container grid) to prevent overlapping icons
    async function tidyLayout() {
      try {
        const dagreLayout = cy.layout(Object.assign({}, layoutOptions, { animate: true, fit: false, boundingBox: undefined, name: 'dagre' }));
        dagreLayout.run();
        await new Promise(r => setTimeout(r, 220));

        // reuse presets from loadDiagram
        const path = selectEl.value;
        const diagramKey = path.split('/').pop();
        const presets = {
          'innovate-cicd-dataflow.json': { 'data-flow': { cols: 2, rows: 3, width: 420 } },
          'innovate-eks-architecture.json': { 'eks-cluster': { cols: 1, rows: 1, width: 620 }, 'ns-monitoring': { cols: 3, rows: 1, width: 520 }, 'ns-prod': { cols: 3, rows: 3, width: 640 }, 'ns-system': { cols: 1, rows: 3, width: 200 } },
          'innovate-high-level-architecture.json': { 'vpc': { cols: 2, rows: 3, width: 420 } },
          'innovate-network-architecture.json': { 'vpc-main': { cols: 2, rows: 4, width: 720 }, 'az-1a': { cols: 1, rows: 3, width: 200 }, 'az-1b': { cols: 1, rows: 3, width: 200 }, 'az-1c': { cols: 1, rows: 3, width: 200 } }
        };

        cy.nodes('.container').forEach(container => {
          const children = cy.nodes().filter(n => n.data('parent') === container.id());
          if (children.length === 0) return;
          const cfg = (presets[diagramKey] && presets[diagramKey][container.id()]) || {};
          const cols = cfg.cols || Math.min(4, children.length) || 1;
          const rows = cfg.rows || Math.max(1, Math.ceil(children.length / cols));
          const width = cfg.width || Math.max(300, Math.min(1400, children.length * 160));
          const height = Math.max(240, rows * 160);
          const cpos = container.position();
          const bbox = { x1: cpos.x - width/2 + 20, y1: cpos.y - height/2 + 18, x2: cpos.x + width/2 - 20, y2: cpos.y + height/2 - 18 };
          try { children.layout({ name: 'grid', boundingBox: bbox, avoidOverlap: true, avoidOverlapPadding: 40, spacingFactor: 1.6, rows, cols, animate: true, fit: false }).run(); } catch (e) { /* ignore */ }
        });
      } catch (e) { console.warn('tidyLayout failed', e); }
    }

    document.getElementById('btnFit').addEventListener('click', async () => { await tidyLayout(); cy.fit(120); applyScalePercent(getScalePercent(), 220); });
    document.getElementById('btnZoomIn').addEventListener('click', () => { try { const z = cy.zoom() * 1.2; cy.animate({ zoom: z }, { duration: 180 }); } catch(e){} });
    document.getElementById('btnZoomOut').addEventListener('click', () => { try { const z = cy.zoom() / 1.2; cy.animate({ zoom: z }, { duration: 180 }); } catch(e){} });

    // Search: highlight matching nodes
    searchEl.addEventListener('input', () => {
      const q = searchEl.value.trim().toLowerCase();
      cy.elements().removeClass('highlight');
      if (!q) return;
      cy.nodes().forEach(n => {
        const text = `${n.data('label') || ''} ${n.data('subtitle') || ''}`.toLowerCase();
        if (text.includes(q)) n.addClass('highlight');
      });
    });

    // Node click -> focus
    cy.on('tap', 'node', (evt) => cy.fit(evt.target, 100));
    selectEl.addEventListener('change', (evt) => loadDiagram(evt.target.value));

    // Initial load: await diagram load, tidy layout and apply user scale
    (async () => {
      await loadDiagram(selectEl.value);
      try {
        await tidyLayout();
        cy.fit(120);
        applyScalePercent(getScalePercent(), 250);
      } catch (e) { /* ignore */ }
    })();
  </script>
</body>
</html>