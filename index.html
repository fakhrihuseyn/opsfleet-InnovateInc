<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Innovate Inc. Architecture Diagrams</title>

  <!-- Cytoscape core + Dagre layout -->
  <script src="https://unpkg.com/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
  <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>

  <style>
    :root {
      --bg: #0f1216;
      --panel: #181d24;
      --text: #e3e6eb;
      --muted: #9aa3ad;
      --accent: #4da3ff;
      --border: #2a313a;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .toolbar {
      display: grid;
      grid-template-columns: 320px 1fr auto auto auto;
      gap: 8px;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    select, input[type="text"], button {
      background: #11161c;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 8px 10px;
      border-radius: 6px;
      outline: none;
    }
    button { cursor: pointer; }
    #cy { width: 100%; height: calc(100vh - 58px); display: block; }
    .legend { padding: 6px 10px; color: var(--muted); font-size: 12px; }

    /* Node / icon styling */
    .node-label { font-size: 12px; color: var(--text); }
  </style>
</head>
<body>
  <div class="toolbar">
    <select id="diagramSelect" title="Select diagram JSON">
      <option value=".infra/innovate-high-level-architecture.json">Innovate High Level Architecture</option>
      <option value=".infra/innovate-cicd-dataflow.json">Innovate CICD Dataflow</option>
      <option value=".infra/innovate-eks-architecture.json">Innovate EKS Architecture</option>
      <option value=".infra/innovate-network-architecture.json">Innovate Network Architecture</option>
    </select>

    <input id="searchBox" type="text" placeholder="Search nodes..." />
    <button id="btnFit">Fit</button>
    <button id="btnZoomIn">+</button>
    <button id="btnZoomOut">âˆ’</button>
  </div>

  <div id="cy"></div>
  <div class="legend">Tip: Click a node to focus. Drag to pan. Scroll to zoom.</div>

  <script>
    cytoscape.use(cytoscapeDagre);

    const cy = cytoscape({
      container: document.getElementById('cy'),
      wheelSensitivity: 0.2,
      boxSelectionEnabled: true,
      style: [
        {
          selector: 'node',
          style: {
            'shape': 'round-rectangle',
            'background-color': '#131820',
            'border-color': '#2a313a',
            'border-width': 1,
            'label': 'data(label)',
            'color': '#e3e6eb',
            'font-size': 11,
            'text-wrap': 'wrap',
            'text-max-width': 120,
            'padding': 4,
            'width': 96,
            'height': 96,
            'text-valign': 'bottom',
            'text-margin-y': -6,
            'text-halign': 'center',
            'overlay-opacity': 0,
          }
        },
        {
          selector: 'node[icon]',
          style: {
            'background-image': 'data(icon)',
            'background-fit': 'contain',
            'background-width': '64px',
            'background-height': '64px',
            'background-clip': 'none',
            'background-image-crossorigin': 'anonymous',
            'background-opacity': 1
          }
        },
        {
          /* containers: VPC, AZs, Subnets, etc. */
          selector: 'node.container',
          style: {
            'shape': 'round-rectangle',
            'background-color': '#131820',
            'border-color': '#4da3ff',
            'border-width': 2,
            'line-style': 'dashed',
            'text-valign': 'top',
            'text-margin-y': -8
          }
        },
        {
          selector: 'edge',
          style: {
            'line-color': '#3b4652',
            'width': 2,
            'target-arrow-shape': 'triangle',
            'target-arrow-color': '#3b4652',
            'curve-style': 'bezier',
            'label': 'data(label)',
            'font-size': 10,
            'text-background-color': '#0f1216',
            'text-background-opacity': 0.7,
            'text-background-padding': 2,
            'color': '#9aa3ad'
          }
        },
        { selector: '.highlight', style: { 'border-color': '#ffd166', 'border-width': 3, 'line-color': '#ffd166', 'target-arrow-color': '#ffd166' } },
        { selector: '.rank-edge', style: { 'line-opacity': 0, 'target-arrow-shape': 'none', 'width': 0 } },
        { selector: ':selected', style: { 'border-color': '#4da3ff', 'border-width': 3 } }
      ]
    });

    // Dagre layout for L->R architecture flow
    const layoutOptions = { name: 'dagre', rankDir: 'LR', nodeSep: 50, edgeSep: 20, rankSep: 80 };

    const selectEl = document.getElementById('diagramSelect');
    const searchEl = document.getElementById('searchBox');

    function normalizeIconPath(icon) {
      if (!icon) return null;
      // Your JSON uses /icons/aws/... -> host under /assets/icons/aws/...
      if (icon.startsWith('/icons/')) return icon.replace('/icons/', '/assets/icons/');
      return icon;
    }

    // Create elements from your schema (supports parentNode, type=container, position.relativeTo, edges)
    function toCytoscapeElements(json) {
      const elements = [];
      const containerIds = new Set();

      // Build nodes

      (json.nodes || []).forEach(n => {
        const display = n.subtitle ? `${n.label || n.id}\n${n.subtitle}` : (n.label || n.id);
        const data = {
          id: n.id,
          label: n.label || n.id,
          subtitle: n.subtitle || null,
          display,
          icon: normalizeIconPath(n.icon),
        };

        const node = { data };

        // Mark container nodes with a class
        if (n.type === 'container') {
          node.classes = 'container';
          containerIds.add(n.id);
        }

        // Compound parent relationship
        if (n.parentNode) data.parent = n.parentNode;

        elements.push(node);

        // Optional: nudging rank if positioned "above" a relative node (e.g., ALB above VPC)
        if (n.position && n.position.relativeTo && n.position.side === 'above') {
          // Dagre trick: add invisible edge from target to this node to raise rank
          elements.push({
            data: {
              id: `rank-${n.id}`,
              source: n.position.relativeTo,
              target: n.id,
              _rankEdge: true
            },
            classes: 'rank-edge'
          });
        }
      });

      // Build edges
      (json.edges || []).forEach(e => {
        const source = e.source || e.from;
        const target = e.target || e.to;
        if (!source || !target) return;
        elements.push({
          data: {
            id: `${source}-->${target}-${Math.random().toString(36).slice(2,7)}`,
            source, target, label: e.label || ''
          }
        });
      });

      return elements;
    }

    async function loadDiagram(path) {
      const res = await fetch(path);
      if (!res.ok) { alert(`Failed to load ${path}: ${res.status}`); return; }
      const json = await res.json();
      const elements = toCytoscapeElements(json);
      cy.elements().remove();
        cy.add(elements);

        // Two-stage layout:
        // 1) Run Dagre on top-level nodes (those without a parent) so global flow is left->right.
        const topLevelEles = cy.elements().filter(ele => {
          if (ele.isEdge()) {
            const src = cy.getElementById(ele.data('source'));
            const tgt = cy.getElementById(ele.data('target'));
            // keep edges that connect top-level nodes (no parent) or connect containers
            return (!src.data('parent') && !tgt.data('parent')) || (src.data('parent') !== tgt.data('parent'));
          }
          return ele.isNode() && !ele.data('parent');
        });

        await (async () => {
          const dagreLayout = cy.layout(Object.assign({}, layoutOptions, { animate: true, fit: false, boundingBox: undefined, name: 'dagre' }));
          try { dagreLayout.run(); } catch (e) { /* ignore layout errors */ }
          // give layout a moment
          await new Promise(r => setTimeout(r, 250));
        })();

        // 2) For each container, layout children inside a grid to make them tidy
        // Use per-diagram presets to tune rows/cols/width for specific containers
        const diagramKey = path.split('/').pop();
        const presets = {
          'innovate-cicd-dataflow.json': {
            'data-flow': { cols: 2, rows: 3, width: 420 },
            // smaller grouped containers
          },
          'innovate-eks-architecture.json': {
            'eks-cluster': { cols: 1, rows: 1, width: 620 },
            'ns-monitoring': { cols: 3, rows: 1, width: 520 },
            'ns-prod': { cols: 3, rows: 3, width: 640 },
            'ns-system': { cols: 1, rows: 3, width: 200 }
          },
          'innovate-high-level-architecture.json': {
            'vpc': { cols: 2, rows: 3, width: 420 }
          },
          'innovate-network-architecture.json': {
            'vpc-main': { cols: 2, rows: 4, width: 720 },
            'az-1a': { cols: 1, rows: 3, width: 200 },
            'az-1b': { cols: 1, rows: 3, width: 200 },
            'az-1c': { cols: 1, rows: 3, width: 200 }
          }
        };

        cy.nodes('.container').forEach(container => {
          const children = cy.nodes().filter(n => n.data('parent') === container.id());
          if (children.length === 0) return;

          // pick preset if available
          const cfg = (presets[diagramKey] && presets[diagramKey][container.id()]) || {};
          const cols = cfg.cols || Math.min(3, children.length) || 1;
          const rows = cfg.rows || Math.max(1, Math.ceil(children.length / cols));
          const width = cfg.width || Math.max(240, Math.min(640, children.length * 90));
          const height = Math.max(160, rows * 90);

          // Compute a bounding box centered inside the container position
          const cpos = container.position();
          const bbox = { x1: cpos.x - width/2 + 20, y1: cpos.y - height/2 + 18, x2: cpos.x + width/2 - 20, y2: cpos.y + height/2 - 18 };

          try {
            children.layout({ name: 'grid', boundingBox: bbox, avoidOverlap: true, rows, cols, animate: true, fit: false }).run();
          } catch (e) { /* ignore */ }
        });

        // Final fit
        cy.fit(20);
    }

    // Controls
    document.getElementById('btnFit').addEventListener('click', () => cy.fit());
    document.getElementById('btnZoomIn').addEventListener('click', () => cy.zoom(cy.zoom() * 1.2));
    document.getElementById('btnZoomOut').addEventListener('click', () => cy.zoom(cy.zoom() / 1.2));

    // Search: highlight matching nodes
    searchEl.addEventListener('input', () => {
      const q = searchEl.value.trim().toLowerCase();
      cy.elements().removeClass('highlight');
      if (!q) return;
      cy.nodes().forEach(n => {
        const text = `${n.data('label') || ''} ${n.data('subtitle') || ''}`.toLowerCase();
        if (text.includes(q)) n.addClass('highlight');
      });
    });

    // Node click -> focus
    cy.on('tap', 'node', (evt) => cy.fit(evt.target, 100));
    selectEl.addEventListener('change', (evt) => loadDiagram(evt.target.value));

    // Initial load
    loadDiagram(selectEl.value);
  </script>
</body>
</html>