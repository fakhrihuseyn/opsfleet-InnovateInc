<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Innovate Inc. Architecture Diagrams</title>

  <!-- Cytoscape core + Dagre layout -->
  <script src="https://unpkg.com/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
  <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="toolbar">
    <div class="brand">InnovateInc</div>
    <div class="center-group">
      <button id="btnDesign" class="center-btn" title="Show architecture design">Architecture Design</button>
      <button id="btnFit" class="center-btn" title="Fit visible elements">Fit Elements</button>
    </div>
    <div class="controls">
    <select id="diagramSelect" title="Select diagram JSON">
      <option value=".infra/innovate-high-level-architecture.json">Innovate High Level Architecture</option>
      <option value=".infra/innovate-cicd-dataflow.json">Innovate CICD Dataflow</option>
      <option value=".infra/innovate-eks-architecture.json">Innovate EKS Architecture</option>
      <option value=".infra/innovate-network-architecture.json">Innovate Network Architecture</option>
    </select>

    <input id="searchBox" type="text" placeholder="Search nodes..." />
    <label class="scale-label">
      <span>Scale</span>
      <input id="scalePercent" class="scale-input" type="number" min="10" max="200" value="95" title="Scale percent applied after fit">
      <span class="scale-unit">%</span>
    </label>
    
    <button id="btnZoomIn">+</button>
    <button id="btnZoomOut">−</button>
    </div>
  </div>

  <div id="cy"></div>
    <div class="legend">Designed for 'Opsfleet' DevOps team | designed By Fakhri Huseynov 2026®</div>
    <div id="tooltip" aria-hidden="true"></div>
    <aside id="designPanel" class="design-panel" aria-hidden="true">
      <div class="title">Architecture Design</div>
      <div class="content" id="designContent">Loading...</div>
    </aside>

  <script>
  // Markdown renderer (marked) loaded from CDN for client-side rendering of ARCHITECTURE_DESIGN.md
  // if blocked, the panel will show raw markdown as fallback
  (function loadMarked(){
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
    s.crossOrigin = 'anonymous';
    s.defer = true;
    document.head.appendChild(s);
  })();
    cytoscape.use(cytoscapeDagre);

    // Read colors from CSS variables so all color values live in style.css
    const __css = getComputedStyle(document.documentElement);
    const colors = {
      bg: __css.getPropertyValue('--bg').trim(),
      panel: __css.getPropertyValue('--panel').trim(),
      text: __css.getPropertyValue('--text').trim(),
      muted: __css.getPropertyValue('--muted').trim(),
      accent: __css.getPropertyValue('--accent').trim(),
      border: __css.getPropertyValue('--border').trim(),
      edge: (__css.getPropertyValue('--edge') || __css.getPropertyValue('--muted')).trim(),
      highlight: (__css.getPropertyValue('--highlight') || '#ffd166').trim()
    };

    const cy = cytoscape({
      container: document.getElementById('cy'),
      wheelSensitivity: 0.2,
      boxSelectionEnabled: true,
      style: [
        {
          selector: 'node',
          style: {
            'shape': 'round-rectangle',
            'background-color': colors.panel,
            'border-color': colors.border,
            'border-width': 1,
            'label': 'data(display)',
            'color': colors.text,
            'font-size': 19.2,
            'text-wrap': 'wrap',
            'text-max-width': 140,
            'padding': 12,
            'width': 140,
            'height': 140,
            'text-valign': 'bottom',
            'text-margin-y': 22,
            'text-halign': 'center',
            'overlay-opacity': 0,
          }
        },
        {
          selector: 'node[icon]',
          style: {
            'background-image': 'data(icon)',
            'background-fit': 'contain',
            'background-width': '76px',
            'background-height': '76px',
            'background-clip': 'none',
            'background-image-crossorigin': 'anonymous',
            'background-opacity': 1
          ,
            // rounded frame + size controlled via data so diagrams can tune icon node dimensions
            'shape': 'round-rectangle',
            'border-width': 2,
            'border-color': colors.border,
            'width': 'data(width)',
            'height': 'data(height)',
            'padding': 8,
            'text-valign': 'bottom',
            'text-margin-y': 8,
            'font-size': 19.2
          }
        },
        {
          selector: 'node#prometheus, node#grafana, node#fluentbit',
          style: {
            'background-width': '1px',
            'background-height': '1px',
            'background-fit': 'contain'
          }
        },
        {
          /* containers: VPC, AZs, Subnets, etc. */
          selector: 'node.container',
          style: {
            'shape': 'round-rectangle',
            'background-color': colors.panel,
            'border-color': colors.accent,
            'border-width': 2,
            'border-style': 'dotted',
            'border-dash-array': '8 8',
            'text-valign': 'top',
            'text-margin-y': -8,
            'font-size': 16,
            // containers sized from data so we can programmatically enclose children
            'width': 'data(width)',
            'height': 'data(height)',
            // containers should not show the large icon background (keeps child icons readable)
            'background-image': 'none',
            'padding': 18
          }
        },
        {
          selector: 'edge',
          style: {
            'line-color': colors.edge,
            'width': 2,
            'target-arrow-shape': 'triangle',
            'target-arrow-color': colors.edge,
            'curve-style': 'bezier',
            'label': 'data(label)',
            'font-size': 14,
            'text-outline-color': colors.bg,
            'text-outline-width': 4,
            'text-background-color': colors.bg,
            'text-background-opacity': 0.85,
            'text-background-padding': 4,
            'color': colors.muted
          }
        },
        { selector: '.highlight', style: { 'border-color': colors.highlight, 'border-width': 3, 'line-color': colors.highlight, 'target-arrow-color': colors.highlight } },
        { selector: '.rank-edge', style: { 'line-opacity': 0, 'target-arrow-shape': 'none', 'width': 0 } },
        { selector: ':selected', style: { 'border-color': colors.accent, 'border-width': 3, 'border-style': 'dashed', 'border-dash-array': '10 6' } }
      ]
    });

    // Dagre layout for L->R architecture flow
    const layoutOptions = { name: 'dagre', rankDir: 'LR', nodeSep: 220, edgeSep: 60, rankSep: 260 };

    // Per-diagram visual configuration (presets, node sizes, layout tweaks)
    const diagramConfigs = {
      'innovate-cicd-dataflow.json': {
        layoutOptions: { nodeSep: 200, rankSep: 220 },
        nodeSize: { width: 110, height: 110 },
        containerDefault: { width: 480, height: 300 },
        presets: {
          'data-flow': { cols: 2, rows: 3, width: 420 }
        }
      },
      'innovate-eks-architecture.json': {
        layoutOptions: { nodeSep: 220, rankSep: 300 },
        nodeSize: { width: 130, height: 130 },
        containerDefault: { width: 620, height: 420 },
        presets: {
          'eks-cluster': { cols: 1, rows: 1, width: 620 },
          'ns-monitoring': { cols: 3, rows: 1, width: 520 },
          'ns-prod': { cols: 3, rows: 3, width: 640 },
          'ns-system': { cols: 1, rows: 3, width: 200 }
        }
      },
      'innovate-high-level-architecture.json': {
        layoutOptions: { nodeSep: 300, rankSep: 360 },
        nodeSize: { width: 160, height: 160 },
        containerDefault: { width: 720, height: 420 },
        presets: {
          'vpc': { cols: 2, rows: 2, width: 560 }
        }
      },
      'innovate-network-architecture.json': {
        layoutOptions: { nodeSep: 180, rankSep: 240 },
        nodeSize: { width: 120, height: 120 },
        containerDefault: { width: 720, height: 420 },
        presets: {
          'vpc-main': { cols: 2, rows: 4, width: 720 },
          'az-1a': { cols: 1, rows: 3, width: 200 },
          'az-1b': { cols: 1, rows: 3, width: 200 },
          'az-1c': { cols: 1, rows: 3, width: 200 }
        }
      }
    };

    const selectEl = document.getElementById('diagramSelect');
    const searchEl = document.getElementById('searchBox');
    const scaleEl = document.getElementById('scalePercent');

    // Initialize scale percent from localStorage or default to 95
    (function initScale() {
      try {
        const saved = localStorage.getItem('scalePercent');
        const val = saved ? Number(saved) : null;
        if (val && Number.isFinite(val)) scaleEl.value = val;
        else scaleEl.value = 95;
      } catch (e) { scaleEl.value = 95; }
    })();

    scaleEl.addEventListener('change', () => {
      const v = Number(scaleEl.value) || 95;
      const clamped = Math.max(10, Math.min(200, v));
      scaleEl.value = clamped;
      try { localStorage.setItem('scalePercent', String(clamped)); } catch (e) {}
    });

    function getScalePercent() { return Math.max(10, Math.min(200, Number(scaleEl.value) || 95)); }

    function applyScalePercent(percent, duration = 250) {
      try {
        const p = (typeof percent === 'number') ? percent : getScalePercent();
        const target = cy.zoom() * (p / 100);
        cy.animate({ zoom: target }, { duration });
      } catch (e) { /* ignore */ }
    }

    function normalizeIconPath(icon) {
      if (!icon) return null;
      // Your JSON uses /icons/aws/... -> host under /assets/icons/aws/...
      if (icon.startsWith('/icons/')) return icon.replace('/icons/', '/assets/icons/');
      return icon;
    }

    // Create elements from your schema (supports parentNode, type=container, position.relativeTo, edges)
    function toCytoscapeElements(json) {
      const elements = [];
      const containerIds = new Set();

      // Build nodes

      (json.nodes || []).forEach(n => {
        const display = n.subtitle ? `${n.label || n.id}\n${n.subtitle}` : (n.label || n.id);
        const data = {
          id: n.id,
          label: n.label || n.id,
          subtitle: n.subtitle || null,
          display,
          icon: normalizeIconPath(n.icon),
        };

        const node = { data };

        // Mark container nodes with a class
        if (n.type === 'container') {
          node.classes = 'container';
          containerIds.add(n.id);
        }

        // Compound parent relationship
        if (n.parentNode) data.parent = n.parentNode;

        elements.push(node);

        // Optional: nudging rank if positioned "above" a relative node (e.g., ALB above VPC)
        if (n.position && n.position.relativeTo && n.position.side === 'above') {
          // Dagre trick: add invisible edge from target to this node to raise rank
          elements.push({
            data: {
              id: `rank-${n.id}`,
              source: n.position.relativeTo,
              target: n.id,
              _rankEdge: true
            },
            classes: 'rank-edge'
          });
        }
      });

      // Build edges
      (json.edges || []).forEach(e => {
        const source = e.source || e.from;
        const target = e.target || e.to;
        if (!source || !target) return;
        elements.push({
          data: {
            id: `${source}-->${target}-${Math.random().toString(36).slice(2,7)}`,
            source,
            target,
            label: e.label || ''
          }
        });
      });

      return elements;
    }

    async function loadDiagram(path) {
      const res = await fetch(path);
      if (!res.ok) { alert(`Failed to load ${path}: ${res.status}`); return; }
      const json = await res.json();
      const elements = toCytoscapeElements(json);
      cy.elements().remove();
        cy.add(elements);

        // Ensure icon paths actually load; if an SVG path 404s, try PNG fallback
        async function ensureIconPaths() {
          const nodesWithIcon = cy.nodes('[icon]').toArray();
          const checked = new Set();
          for (const n of nodesWithIcon) {
            const icon = n.data('icon');
            if (!icon || checked.has(icon)) continue;
            checked.add(icon);
            try {
              const r = await fetch(icon, { method: 'GET' });
              if (!r.ok) {
                // try replacing .svg with .png as fallback
                if (icon.endsWith('.svg')) {
                  const alt = icon.replace(/\.svg$/, '.png');
                  try {
                    const r2 = await fetch(alt, { method: 'GET' });
                    if (r2.ok) {
                      // update all nodes referencing the failed icon
                      cy.nodes(`[icon="${icon}"]`).forEach(x => x.data('icon', alt));
                    }
                  } catch (e) { /* ignore */ }
                }
              }
            } catch (e) { /* ignore network errors */ }
          }
        }
        // run but don't block layout too long
        ensureIconPaths().catch(() => {});

        // apply per-diagram visual config (node sizes, container defaults)
        const diagramKey = path.split('/').pop();
        const dcfg = diagramConfigs[diagramKey] || {};
        const localLayoutOptions = Object.assign({}, layoutOptions, dcfg.layoutOptions || {});

        // set icon node sizes from config and increase by 20% for better visibility
        const iconSize = (dcfg.nodeSize) ? dcfg.nodeSize : { width: 120, height: 120 };
        cy.nodes('[icon]').forEach(n => {
          const baseW = n.data('width') || iconSize.width;
          const baseH = n.data('height') || iconSize.height;
          n.data('width', Math.round(baseW * 1.2));
          n.data('height', Math.round(baseH * 1.2));
        });
        // initialize container default sizes
        cy.nodes('.container').forEach(c => { const def = dcfg.containerDefault || { width: 360, height: 240 }; c.data('width', c.data('width') || def.width); c.data('height', c.data('height') || def.height); });

        // Two-stage layout: use diagram-specific layout options when available
        const topLevelEles = cy.elements().filter(ele => {
          if (ele.isEdge()) {
            const src = cy.getElementById(ele.data('source'));
            const tgt = cy.getElementById(ele.data('target'));
            // keep edges that connect top-level nodes (no parent) or connect containers
            return (!src.data('parent') && !tgt.data('parent')) || (src.data('parent') !== tgt.data('parent'));
          }
          return ele.isNode() && !ele.data('parent');
        });

        await (async () => {
          const dagreLayout = cy.layout(Object.assign({}, localLayoutOptions, { animate: true, fit: false, boundingBox: undefined, name: 'dagre' }));
          try { dagreLayout.run(); } catch (e) { /* ignore layout errors */ }
          // give layout a moment
          await new Promise(r => setTimeout(r, 250));
        })();

        // 2) For each container, layout children inside a grid to make them tidy
        // Use per-diagram presets from the diagram config
        const presets = dcfg.presets || {};

        // Use an async for-loop so we can await between layout steps and avoid JS syntax errors
        const containers = cy.nodes('.container').toArray();
        for (const container of containers) {
          const children = cy.nodes().filter(n => n.data('parent') === container.id());
          if (children.length === 0) continue;

          // pick preset if available
          const cfg = presets[container.id()] || {};
          const cols = cfg.cols || Math.min(4, children.length) || 1;
          const rows = cfg.rows || Math.max(1, Math.ceil(children.length / cols));
          // wider cell sizes to avoid overlap between icons and labels
          const width = cfg.width || Math.max(400, Math.min(2200, children.length * 240));
          const height = Math.max(240, rows * 180);

          // Compute a bounding box centered inside the container position (initial placement)
          const cpos = container.position();
          const bbox = { x1: cpos.x - width/2 + 20, y1: cpos.y - height/2 + 18, x2: cpos.x + width/2 - 20, y2: cpos.y + height/2 - 18 };

          try {
            // deterministic cell placement for children
            const cellW = (bbox.x2 - bbox.x1) / cols;
            const cellH = (bbox.y2 - bbox.y1) / rows;
            const arr = children.toArray().sort((a, b) => ('' + a.id()).localeCompare(b.id()));
            arr.forEach((child, idx) => {
              const r = Math.floor(idx / cols);
              const c = idx % cols;
              const x = bbox.x1 + c * cellW + cellW / 2;
              const y = bbox.y1 + r * cellH + cellH / 2;
              child.position({ x, y });
            });
            await new Promise(r => setTimeout(r, 120));
            const childBB = children.boundingBox({ includeNodes: true });
            if (childBB && Number.isFinite(childBB.x1)) {
              const cx = (childBB.x1 + childBB.x2) / 2;
              const cyPos = (childBB.y1 + childBB.y2) / 2;
              container.position({ x: cx, y: cyPos });
            }
          } catch (e) { /* ignore */ }
        }

        // Small EKS monitoring nudge: avoid Grafana/Prometheus/FluentBit overlap
        try {
          if (diagramKey === 'innovate-eks-architecture.json') {
            const prom = cy.getElementById('prometheus');
            const graf = cy.getElementById('grafana');
            const fb = cy.getElementById('fluentbit');
            const monitorContainer = cy.getElementById('ns-monitoring');
            if (prom.length && graf.length && fb.length && monitorContainer.length) {
              const center = monitorContainer.position();
              // place them horizontally with wider separation to avoid overlap
              const spread = 220; // increased spacing
              prom.position({ x: center.x - spread, y: center.y });
              graf.position({ x: center.x, y: center.y });
              fb.position({ x: center.x + spread, y: center.y });

              // ensure a minimum visual size for these monitoring icons
              [prom, graf, fb].forEach(n => {
                const w = Number(n.data('width')) || 120;
                const h = Number(n.data('height')) || 120;
                n.data('width', Math.max(w, 140));
                n.data('height', Math.max(h, 140));
              });

              // resize the monitoring container to enclose children with padding
              const childBB = cy.nodes().filter(n => n.data('parent') === monitorContainer.id()).boundingBox({ includeNodes: true });
              if (childBB && Number.isFinite(childBB.x1)) {
                const paddingX = 120;
                const paddingY = 100;
                const newW = Math.max(monitorContainer.data('width') || 360, (childBB.x2 - childBB.x1) + paddingX);
                const newH = Math.max(monitorContainer.data('height') || 240, (childBB.y2 - childBB.y1) + paddingY);
                monitorContainer.data('width', newW);
                monitorContainer.data('height', newH);
                // center container on children
                const cx = (childBB.x1 + childBB.x2) / 2;
                const cyPos = (childBB.y1 + childBB.y2) / 2;
                monitorContainer.position({ x: cx, y: cyPos });
              }
            }
          }
        } catch (e) { /* ignore if nodes absent */ }

        // Final fit (show everything and then apply user-chosen scale percent)
        cy.fit(120);
        applyScalePercent(getScalePercent(), 250);
    }

    // Controls
    // Fit now re-runs the tidy layout (dagre + per-container grid) to prevent overlapping icons
    async function tidyLayout() {
      try {
        // use diagram-specific layout options
        const path = selectEl.value;
        const diagramKey = path.split('/').pop();
        const dcfg = diagramConfigs[diagramKey] || {};
        const localLayoutOptions = Object.assign({}, layoutOptions, dcfg.layoutOptions || {});
        const dagreLayout = cy.layout(Object.assign({}, localLayoutOptions, { animate: true, fit: false, boundingBox: undefined, name: 'dagre' }));
        dagreLayout.run();
        await new Promise(r => setTimeout(r, 220));

        // per-diagram presets
        const presets = dcfg.presets || {};

        cy.nodes('.container').forEach(container => {
          const children = cy.nodes().filter(n => n.data('parent') === container.id());
          if (children.length === 0) return;
          const cfg = presets[container.id()] || {};
          const cols = cfg.cols || Math.min(4, children.length) || 1;
          const rows = cfg.rows || Math.max(1, Math.ceil(children.length / cols));
          const width = cfg.width || Math.max(300, Math.min(1400, children.length * 160));
          const height = Math.max(240, rows * 160);
          const cpos = container.position();
          const bbox = { x1: cpos.x - width/2 + 20, y1: cpos.y - height/2 + 18, x2: cpos.x + width/2 - 20, y2: cpos.y + height/2 - 18 };
          try {
            // deterministic explicit placement
            const cellW = (bbox.x2 - bbox.x1) / cols;
            const cellH = (bbox.y2 - bbox.y1) / rows;
            const arr = children.toArray().sort((a, b) => ('' + a.id()).localeCompare(b.id()));
            arr.forEach((child, idx) => {
              const r = Math.floor(idx / cols);
              const c = idx % cols;
              const x = bbox.x1 + c * cellW + cellW / 2;
              const y = bbox.y1 + r * cellH + cellH / 2;
              child.position({ x, y });
            });
          } catch (e) { /* ignore */ }
        });

        // allow settle then resize containers
        await new Promise(r => setTimeout(r, 160));
        cy.nodes('.container').forEach(container => {
          const children = cy.nodes().filter(n => n.data('parent') === container.id());
          if (children.length === 0) return;
          const childBB = children.boundingBox({ includeNodes: true });
          if (childBB && Number.isFinite(childBB.x1)) {
            const cx = (childBB.x1 + childBB.x2) / 2;
            const cyPos = (childBB.y1 + childBB.y2) / 2;
            const paddingX = 48;
            const paddingY = 72;
            const newW = Math.max(220, (childBB.x2 - childBB.x1) + paddingX);
            const newH = Math.max(180, (childBB.y2 - childBB.y1) + paddingY);
            container.data('width', newW);
            container.data('height', newH);
            container.position({ x: cx, y: cyPos });
          }
        });
      } catch (e) { console.warn('tidyLayout failed', e); }
    }

    document.getElementById('btnFit').addEventListener('click', async () => { await tidyLayout(); cy.fit(120); applyScalePercent(getScalePercent(), 220); });

    // Zoom in/out while preserving the current pan (prevents unintended panning)
    document.getElementById('btnZoomIn').addEventListener('click', () => {
      try {
        const currentPan = cy.pan();
        const z = cy.zoom() * 1.2;
        cy.animate({ zoom: z, pan: currentPan }, { duration: 180 });
      } catch (e) { /* ignore */ }
    });

    document.getElementById('btnZoomOut').addEventListener('click', () => {
      try {
        const currentPan = cy.pan();
        const z = cy.zoom() / 1.2;
        cy.animate({ zoom: z, pan: currentPan }, { duration: 180 });
      } catch (e) { /* ignore */ }
    });

    // Search: highlight matching nodes
    searchEl.addEventListener('input', () => {
      const q = searchEl.value.trim().toLowerCase();
      cy.elements().removeClass('highlight');
      if (!q) return;
      cy.nodes().forEach(n => {
        const text = `${n.data('label') || ''} ${n.data('subtitle') || ''}`.toLowerCase();
        if (text.includes(q)) n.addClass('highlight');
      });
    });

    // Node click -> gentle zoom + center (moderate, not full-fit)
    cy.on('tap', 'node', (evt) => {
      try {
        const node = evt.target;
        const nodePos = node.position();
        const currentZoom = cy.zoom();
        // mild scale up on click (25% max), clamped to reasonable range
        const targetZoom = Math.max(0.5, Math.min(2.5, currentZoom * 1.25));
        const pan = { x: cy.width() / 2 - nodePos.x * targetZoom, y: cy.height() / 2 - nodePos.y * targetZoom };
        cy.animate({ zoom: targetZoom, pan }, { duration: 260 });
      } catch (e) { /* fallback: no-op */ }
    });

    // Architecture design panel: lazy-load and render ARCHITECTURE_DESIGN.md
    let designLoaded = false;
    const designBtn = document.getElementById('btnDesign');
    const designPanel = document.getElementById('designPanel');
    const designContent = document.getElementById('designContent');

    async function openDesignPanel() {
      designPanel.classList.add('open');
      designPanel.setAttribute('aria-hidden', 'false');
      if (!designLoaded) {
        try {
          const res = await fetch('ARCHITECTURE_DESIGN.md');
          if (res.ok) {
            const md = await res.text();
            if (window.marked) {
              designContent.innerHTML = marked.parse(md);
            } else {
              // fallback: basic preformatted display
              designContent.textContent = md;
            }
          } else {
            designContent.textContent = `Failed to load ARCHITECTURE_DESIGN.md: ${res.status}`;
          }
        } catch (e) {
          designContent.textContent = 'Error loading design document.';
        }
        designLoaded = true;
      }
    }

    function closeDesignPanel() {
      designPanel.classList.remove('open');
      designPanel.setAttribute('aria-hidden', 'true');
    }

    designBtn.addEventListener('click', () => { if (designPanel.classList.contains('open')) closeDesignPanel(); else openDesignPanel(); });
    // Auto-hide design panel when clicking outside the panel or the toggle button
    document.addEventListener('click', (evt) => {
      try {
        const t = evt.target;
        if (!designPanel.classList.contains('open')) return;
        // if click was inside the panel or on the toggle button, keep it open
        if (designPanel.contains(t) || designBtn.contains(t)) return;
        closeDesignPanel();
      } catch (e) { /* ignore */ }
    });
    // Hover interactions for icon nodes: highlight, enlarge, and show tooltip
    const tooltipEl = document.getElementById('tooltip');
    const ICON_HOVER_SCALE = 1.2;
    const ICON_BASE_FONT = 19.2;
    cy.on('mouseover', 'node[icon]', (evt) => {
      const node = evt.target;
      node.addClass('hover');
      // animate to ~1.15x size
      try {
        const w = Number(node.data('width')) || 120;
        const h = Number(node.data('height')) || 120;
        node.animate({ style: { width: Math.round(w * ICON_HOVER_SCALE), height: Math.round(h * ICON_HOVER_SCALE), 'border-width': 3, 'font-size': Math.round(ICON_BASE_FONT * ICON_HOVER_SCALE) } }, { duration: 120 });
      } catch (e) {}
      // show tooltip near mouse
      try {
        tooltipEl.textContent = node.data('display') || node.data('label') || node.id();
        tooltipEl.style.display = 'block';
        const ev = evt.originalEvent;
        if (ev && ev.clientX != null) {
          tooltipEl.style.left = (ev.clientX + 12) + 'px';
          tooltipEl.style.top = (ev.clientY + 12) + 'px';
        }
      } catch (e) {}
    });

    cy.on('mousemove', 'node[icon]', (evt) => {
      const ev = evt.originalEvent;
      if (ev && tooltipEl.style.display === 'block') {
        tooltipEl.style.left = (ev.clientX + 12) + 'px';
        tooltipEl.style.top = (ev.clientY + 12) + 'px';
      }
    });

    cy.on('mouseout', 'node[icon]', (evt) => {
      const node = evt.target;
      node.removeClass('hover');
      try {
        const w = Number(node.data('width')) || 120;
        const h = Number(node.data('height')) || 120;
        node.animate({ style: { width: Math.round(w), height: Math.round(h), 'border-width': 2, 'font-size': ICON_BASE_FONT } }, { duration: 120 });
      } catch (e) {}
      tooltipEl.style.display = 'none';
    });
    selectEl.addEventListener('change', (evt) => loadDiagram(evt.target.value));

    // Initial load: await diagram load, tidy layout and apply user scale
    (async () => {
      await loadDiagram(selectEl.value);
      try {
        await tidyLayout();
        cy.fit(120);
        applyScalePercent(getScalePercent(), 250);
      } catch (e) { /* ignore */ }
    })();
  </script>
</body>
</html>